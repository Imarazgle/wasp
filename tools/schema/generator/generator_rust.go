// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

package generator

import (
	"os"

	"github.com/iotaledger/wasp/tools/schema/generator/rstemplates"
	"github.com/iotaledger/wasp/tools/schema/model"
)

type RustGenerator struct {
	GenBase
}

var _ IGenerator = new(RustGenerator)

func NewRustGenerator(s *model.Schema) *RustGenerator {
	g := &RustGenerator{}
	g.init(s, rstemplates.TypeDependent, rstemplates.Templates)
	return g
}

func (g *RustGenerator) Cleanup() {
	g.cleanCommonFiles()

	// now clean up Wasm VM host stub crate
	g.cleanFolder(g.folder + "../../" + g.s.PackageName + "_main")
}

func (g *RustGenerator) Generate() error {
	err := g.generateCommonFiles()
	if err != nil {
		return err
	}

	// now generate language-specific files
	if g.s.CoreContracts {
		return g.createSourceFile("mod", true)
	}

	// user may choose to change these after generating, so we never overwrite them
	err = g.GenerateCargoToml("Sc", false)
	if err != nil {
		return err
	}

	// now generate Wasm VM host stub crate folder
	g.folder += "../../" + g.s.PackageName + "_main/src/"
	err = os.MkdirAll(g.folder, 0o755)
	if err != nil {
		return err
	}

	// would have preferred to use main.rs, but don't want to generate both a lib.rs
	// AND a main.rs so the mainRs template is tricked into generating a different
	// lib.rs than the actual lib.rs by using a relative path as template key
	err = g.createSourceFile("../src/lib", !g.s.CoreContracts)
	if err != nil {
		return err
	}

	// this is fully generated by schema tool, so we allow overwrite
	return g.GenerateCargoToml("Main", true)
}

func (g *RustGenerator) GenerateCargoToml(cargoMain string, overwrite bool) error {
	const cargoToml = "../Cargo.toml"
	g.keys["cargoMain"] = cargoMain
	// note that either Cargo.toml might have been overridden,
	// so to play it safe do not overwrite that one
	err := g.createFile(g.folder+cargoToml, false, func() {
		g.emit(cargoToml)
	})
	if err != nil {
		return err
	}

	const license = "../LICENSE"
	err = g.createFile(g.folder+license, overwrite, func() {
		g.emit(license)
	})
	if err != nil {
		return err
	}

	const readMe = "../README.md"
	return g.createFile(g.folder+readMe, overwrite, func() {
		g.emit(readMe + " " + cargoMain)
	})
}
